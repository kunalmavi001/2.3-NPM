"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cache = void 0;
var rxjs_1 = require("rxjs");
var CV = require("./CacheValue");
var Ma = require("fp-ts/lib/Map");
var O = require("fp-ts/lib/Option");
var TE = require("fp-ts/lib/TaskEither");
var operators_1 = require("rxjs/operators");
var E = require("fp-ts/lib/Either");
var function_1 = require("fp-ts/lib/function");
var pipeable_1 = require("fp-ts/lib/pipeable");
var Cache = (function () {
    function Cache(fetch, strategy) {
        var _this = this;
        this.fetch = fetch;
        this.strategy = strategy;
        this.subjects = new Map();
        this.lookup = function (input) { return _this._lookup(input, _this.subjects); };
        this.member = function_1.flow(this.lookup, O.isSome);
        this.unsafeLookup = function_1.flow(this.lookup, O.getOrElse(function () {
            throw new Error('unsafe lookup failed');
        }));
        this.emitEvent = function (input, cacheValue) {
            pipeable_1.pipe(input, _this.lookup, O.fold(function () { }, function (s) {
                s.next(cacheValue);
            }));
        };
        this.getOrCreateSubject = function (input) {
            if (!_this.member(input)) {
                _this.subjects.set(input, new rxjs_1.BehaviorSubject(CV.cacheValueInitial));
            }
            return _this.unsafeLookup(input);
        };
        this.createPending = function (input) {
            return function () {
                var pending = pipeable_1.pipe(input, _this.fetch, TE.bimap(function (error) {
                    _this.emitEvent(input, CV.cacheValueError(error, new Date()));
                    return error;
                }, function (value) {
                    _this.emitEvent(input, CV.cacheValueResolved(value, new Date()));
                    return value;
                }))();
                _this.emitEvent(input, CV.cacheValuePending(pending, new Date()));
                return pending;
            };
        };
        this.run = function (input) {
            return pipeable_1.pipe(_this.getOrCreateSubject(input).value, O.some, O.filter(_this.strategy.filter), O.fold(function () { return _this.createPending(input); }, CV.fold(function () { return _this.createPending(input); }, function (pending) { return function () { return pending; }; }, TE.left, TE.right)));
        };
        this.sameInvalidationFrame = false;
        this.invalidate = function (input) {
            return pipeable_1.pipe(TE.fromIOEither(function () {
                if (!_this.sameInvalidationFrame) {
                    _this.sameInvalidationFrame = true;
                    _this.emitEvent(input, CV.cacheValueInitial);
                    Promise.resolve().then(function () {
                        _this.sameInvalidationFrame = false;
                    });
                }
                return E.right(undefined);
            }), TE.chain(function () { return _this.run(input); }));
        };
        this.observe = function (input) {
            var observable = _this.getOrCreateSubject(input)
                .asObservable()
                .pipe(operators_1.distinctUntilChanged(_this.strategy.cacheValueEq.equals));
            return rxjs_1.empty().pipe(operators_1.tap(null, null, function () {
                _this.run(input)();
            }), operators_1.concat(observable));
        };
        this._lookup = Ma.lookup(strategy.inputEq);
    }
    return Cache;
}());
exports.Cache = Cache;
