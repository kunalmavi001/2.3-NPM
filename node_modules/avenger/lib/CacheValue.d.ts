import { Either } from 'fp-ts/lib/Either';
import { Eq } from 'fp-ts/lib/Eq';
export interface CacheValueInitial {
    readonly _tag: 'Initial';
}
export interface CacheValuePending<E, A> {
    readonly _tag: 'Pending';
    readonly pending: Promise<Either<E, A>>;
    readonly updated: Date;
}
export interface CacheValueError<E> {
    readonly _tag: 'Error';
    readonly error: E;
    readonly updated: Date;
}
export interface CacheValueResolved<A> {
    readonly _tag: 'Resolved';
    readonly resolved: A;
    readonly updated: Date;
}
export declare type CacheValue<E, A> = CacheValueInitial | CacheValuePending<E, A> | CacheValueError<E> | CacheValueResolved<A>;
export declare const cacheValueInitial: CacheValue<never, never>;
export declare function cacheValuePending<E = never, A = never>(pending: Promise<Either<E, A>>, updated: Date): CacheValue<E, A>;
export declare function cacheValueError<E = never, A = never>(error: E, updated: Date): CacheValue<E, A>;
export declare function cacheValueResolved<E = never, A = never>(resolved: A, updated: Date): CacheValue<E, A>;
export declare function fold<E, A, B>(onCacheValueInitial: () => B, onCacheValuePending: (pending: Promise<Either<E, A>>, updated: Date) => B, onCacheValueError: (error: E, updated: Date) => B, onCacheValueResolved: (resolved: A, updated: Date) => B): (ma: CacheValue<E, A>) => B;
export declare function getEq<E, A>(Eqe: Eq<E>, Eqa: Eq<A>): Eq<CacheValue<E, A>>;
