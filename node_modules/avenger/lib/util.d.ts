import { ObservableQuery } from './Query';
export declare type EnforceNonEmptyRecord<R> = keyof R extends never ? never : R;
declare type MatchingPropNames<T, X> = {
    [K in keyof T]: T[K] extends X ? K : never;
}[keyof T];
declare type NonMatchingPropNames<T, X> = {
    [K in keyof T]: T[K] extends X ? never : K;
}[keyof T];
export declare type ObservableQueries = Record<string, ObservableQuery<any, any, any>>;
export declare type VoidInputObservableQueries = Record<string, ObservableQuery<void, any, any>>;
export declare type ProductA<R extends ObservableQueries> = NonMatchingPropNames<R, ObservableQuery<void, any, any>> extends never ? void : {
    [K in MatchingPropNames<R, ObservableQuery<void, any, any>>]?: never;
} & {
    [K in NonMatchingPropNames<R, ObservableQuery<void, any, any>>]: R[K]['_A'];
};
export declare type ProductL<R extends ObservableQueries> = {
    [K in keyof R]: R[K]['_L'];
}[keyof R];
export declare type ProductP<R extends ObservableQueries> = {
    [K in keyof R]: R[K]['_P'];
};
export {};
