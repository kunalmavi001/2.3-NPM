import { Monad2 } from 'fp-ts/lib/Monad';
import { Bifunctor2 } from 'fp-ts/lib/Bifunctor';
import { Alt2 } from 'fp-ts/lib/Alt';
import * as Eq from 'fp-ts/lib/Eq';
declare module 'fp-ts/lib/HKT' {
    interface URItoKind2<E, A> {
        QueryResult: QueryResult<E, A>;
    }
}
export declare const URI = "QueryResult";
export declare type URI = typeof URI;
export interface QueryResultLoading {
    readonly _tag: 'Loading';
}
export interface QueryResultFailure<E> {
    readonly _tag: 'Failure';
    readonly failure: E;
    readonly loading: boolean;
}
export interface QueryResultSuccess<A> {
    readonly _tag: 'Success';
    readonly success: A;
    readonly loading: boolean;
}
export declare type QueryResult<E, A> = QueryResultLoading | QueryResultFailure<E> | QueryResultSuccess<A>;
export declare const queryResultLoading: QueryResult<never, never>;
export declare function queryResultFailure<E = never, A = never>(failure: E, loading: boolean): QueryResult<E, A>;
export declare function queryResultSuccess<E = never, A = never>(success: A, loading: boolean): QueryResult<E, A>;
export declare function fold<E, A, B>(onLoading: () => B, onFailure: (failure: E, loading: boolean) => B, onSuccess: (success: A, loading: boolean) => B): (ma: QueryResult<E, A>) => B;
export declare const queryResult: Bifunctor2<URI> & Monad2<URI> & Alt2<URI>;
declare const ap: <E, A>(fa: QueryResult<E, A>) => <B>(fab: QueryResult<E, (a: A) => B>) => QueryResult<E, B>, apFirst: <E, B>(fb: QueryResult<E, B>) => <A>(fa: QueryResult<E, A>) => QueryResult<E, A>, apSecond: <E, B>(fb: QueryResult<E, B>) => <A>(fa: QueryResult<E, A>) => QueryResult<E, B>, bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: QueryResult<E, A>) => QueryResult<G, B>, chain: <E, A, B>(f: (a: A) => QueryResult<E, B>) => (ma: QueryResult<E, A>) => QueryResult<E, B>, chainFirst: <E, A, B>(f: (a: A) => QueryResult<E, B>) => (ma: QueryResult<E, A>) => QueryResult<E, A>, flatten: <E, A>(mma: QueryResult<E, QueryResult<E, A>>) => QueryResult<E, A>, map: <A, B>(f: (a: A) => B) => <E>(fa: QueryResult<E, A>) => QueryResult<E, B>, mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: QueryResult<E, A>) => QueryResult<G, A>;
export { ap, apFirst, apSecond, bimap, chain, chainFirst, flatten, map, mapLeft };
export declare function getEq<E, A>(Eqe: Eq.Eq<E>, Eqa: Eq.Eq<A>): Eq.Eq<QueryResult<E, A>>;
