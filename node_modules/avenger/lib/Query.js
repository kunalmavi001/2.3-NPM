"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.map = exports.product = exports.compose = exports.queryShallow = exports.queryStrict = exports.query = void 0;
var TE = require("fp-ts/lib/TaskEither");
var Cache_1 = require("./Cache");
var S = require("./Strategy");
var Eq = require("fp-ts/lib/Eq");
var CV = require("./CacheValue");
var R = require("fp-ts/lib/Record");
var pipeable_1 = require("fp-ts/lib/pipeable");
function queryPhantoms() {
    return null;
}
function query(fetch) {
    return function (strategy) {
        var cache = new Cache_1.Cache(fetch, strategy);
        return __assign(__assign({ type: 'cached' }, queryPhantoms()), { inputEq: strategy.inputEq, cache: cache, run: cache.run, invalidate: cache.invalidate });
    };
}
exports.query = query;
function queryStrict(fetch, makeStrategy) {
    return query(fetch)(makeStrategy(Eq.eqStrict, CV.getEq(Eq.eqStrict, Eq.eqStrict)));
}
exports.queryStrict = queryStrict;
function queryShallow(fetch, makeStrategy) {
    return query(fetch)(makeStrategy(S.eqShallow, CV.getEq(S.eqShallow, S.eqShallow)));
}
exports.queryShallow = queryShallow;
function compose(master, slave) {
    return __assign(__assign({ type: 'composition' }, queryPhantoms()), { inputEq: master.inputEq, master: master, slave: slave, run: function (a1) {
            return TE.taskEither.chain(master.run(a1), function (a2) {
                return slave.run(a2);
            });
        }, invalidate: function (a1) {
            return TE.taskEither.chain(master.invalidate(a1), function (a2) { return slave.invalidate(a2); });
        } });
}
exports.compose = compose;
var sequenceRecordTaskEither = R.sequence(TE.taskEither);
function product(queries) {
    var runQueries = function (a) {
        return pipeable_1.pipe(queries, R.mapWithIndex(function (k, query) { return query.run((a || {})[k]); }));
    };
    var run = function (a) { return sequenceRecordTaskEither(runQueries(a)); };
    var invalidateQueries = function (a) {
        return pipeable_1.pipe(queries, R.mapWithIndex(function (k, query) { return query.invalidate((a || {})[k]); }));
    };
    var invalidate = function (a) { return sequenceRecordTaskEither(invalidateQueries(a)); };
    return __assign(__assign({ type: 'product' }, queryPhantoms()), { inputEq: pipeable_1.pipe(queries, R.map(function (q) { return q.inputEq; }), Eq.getStructEq, Eq.contramap(function (i) { return i || {}; })), queries: queries, run: run, invalidate: invalidate });
}
exports.product = product;
function map(fa, f) {
    return compose(fa, queryStrict(function (a) { return TE.taskEither.of(f(a)); }, S.available));
}
exports.map = map;
